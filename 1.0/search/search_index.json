{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"YData SDK","text":"<p>YData SDK for improved data quality everywhere!</p> <p>ydata-sdk is coming soon. If you want to know more reach out to us!</p> <p>I want to know more</p>"},{"location":"#overview","title":"Overview","text":"<p>The YData SDK is an ecosystem of methods that allows users to, through a python interface, adopt a Data-Centric approach towards the AI development. The solution includes a set of integrated components for data ingestion, standardized data quality evaluation and data improvement, such as synthetic data generation, allowing an iterative improvement of the datasets used in high-impact business applications.</p> <p>Synthetic data can be used as Machine Learning performance enhancer, to augment or mitigate the presence of bias in real data. Furthermore, it can be used as a Privacy Enhancing Technology, to enable data-sharing initiatives or even to fuel testing environments. </p> <p>Under the YData-SDK hood, you can find a set of algorithms and metrics based on statistics and deep learning based techniques, that will help you to accelerate your data preparation. </p>"},{"location":"#current-functionality","title":"Current functionality","text":"<p>YData SDK is currently composed by the following main modules:</p> <ul> <li> <p>Datasources</p> </li> <li> <p>Synthesizers</p> </li> <li> <p>Synthetic data quality report</p> </li> <li> <p>Profiling</p> </li> </ul>"},{"location":"reference/api/common/client/","title":"Get client","text":"<p>Deduce how to initialize or retrieve the client.</p> <p>This is meant to be a zero configuration for the user.</p> Create and set a client globally <pre><code>from ydata.sdk.client import get_client\nget_client(set_as_global=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>client_or_creds</code> <code>Optional[Union[Client, dict, str, Path]]</code> <p>Client to forward or credentials for initialization</p> <code>None</code> <code>set_as_global</code> <code>bool</code> <p>If <code>True</code>, set client as global</p> <code>False</code> <code>wait_for_auth</code> <code>bool</code> <p>If <code>True</code>, wait for the user to authenticate</p> <code>True</code> <p>Returns:</p> Type Description <code>Client</code> <p>Client instance</p> Source code in <code>ydata/sdk/common/client/utils.py</code> <pre><code>def get_client(client_or_creds: Optional[Union[Client, dict, str, Path]] = None, set_as_global: bool = False, wait_for_auth: bool = True) -&gt; Client:\n\"\"\"Deduce how to initialize or retrieve the client.\n    This is meant to be a zero configuration for the user.\n    Example: Create and set a client globally\n            ```py\n            from ydata.sdk.client import get_client\n            get_client(set_as_global=True)\n            ```\n    Args:\n        client_or_creds (Optional[Union[Client, dict, str, Path]]): Client to forward or credentials for initialization\n        set_as_global (bool): If `True`, set client as global\n        wait_for_auth (bool): If `True`, wait for the user to authenticate\n    Returns:\n        Client instance\n    \"\"\"\nclient = None\nglobal WAITING_FOR_CLIENT\ntry:\n# If a client instance is set globally, return it\nif not set_as_global and Client.GLOBAL_CLIENT is not None:\nreturn Client.GLOBAL_CLIENT\n# Client exists, forward it\nif isinstance(client_or_creds, Client):\nreturn client_or_creds\n# Explicit credentials\n''' # For the first version, we deactivate explicit credentials via string or file for env var only\n        if isinstance(client_or_creds, (dict, str, Path)):\n            if isinstance(client_or_creds, str):  # noqa: SIM102\n                if Path(client_or_creds).is_file():\n                    client_or_creds = Path(client_or_creds)\n            if isinstance(client_or_creds, Path):\n                client_or_creds = json.loads(client_or_creds.open().read())\n            return Client(credentials=client_or_creds)\n        '''\n# Last try with environment variables\nif client_or_creds is None:\nclient = _client_from_env(wait_for_auth=wait_for_auth)\nexcept ClientHandshakeError as e:\nwait_for_auth = False  # For now deactivate wait_for_auth until the backend is ready\nif wait_for_auth:\nWAITING_FOR_CLIENT = True\nstart = time()\nlogin_message_printed = False\nwhile client is None:\nif not login_message_printed:\nprint(\nf\"The token needs to be refreshed - please validate your token by browsing at the following URL:\\n\\n\\t{e.auth_link}\")\nlogin_message_printed = True\nwith suppress(ClientCreationError):\nsleep(BACKOFF)\nclient = get_client(wait_for_auth=False)\nnow = time()\nif now - start &gt; CLIENT_INIT_TIMEOUT:\nWAITING_FOR_CLIENT = False\nbreak\nif client is None and not WAITING_FOR_CLIENT:\nraise ClientCreationError\nreturn client\n</code></pre> <p>Main Client class used to abstract the connection to the backend.</p> <p>A normal user should not have to instanciate a <code>Client</code> by itself. However, in the future it will be useful for power-users to manage projects and connections.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>Optional[dict]</code> <p>(optional) Credentials to connect</p> <code>None</code> <code>project</code> <code>Optional[Project]</code> <p>(optional) Project to connect to. If not specified, the client will connect to the default user's project.</p> <code>None</code> Source code in <code>ydata/sdk/common/client/client.py</code> <pre><code>@typechecked\nclass Client(metaclass=SingletonClient):\n\"\"\"Main Client class used to abstract the connection to the backend.\n    A normal user should not have to instanciate a [`Client`][ydata.sdk.common.client.Client] by itself.\n    However, in the future it will be useful for power-users to manage projects and connections.\n    Args:\n        credentials (Optional[dict]): (optional) Credentials to connect\n        project (Optional[Project]): (optional) Project to connect to. If not specified, the client will connect to the default user's project.\n    \"\"\"\ncodes = codes\ndef __init__(self, credentials: Optional[Union[str, dict]] = None, project: Optional[Project] = None, set_as_global: bool = False):\nself._base_url = environ.get(\"YDATA_BASE_URL\", DEFAULT_URL)\nself._scheme = 'https'\nself._headers = {'Authorization': credentials}\nself._http_client = httpClient(\nheaders=self._headers, timeout=Timeout(10, read=None))\nself._handshake()\nself._project = project if project is not None else self._get_default_project(\ncredentials)\nself.project = project\nif set_as_global:\nself.__set_global()\ndef post(self, endpoint: str, data: Optional[dict] = None, json: Optional[dict] = None, files: Optional[dict] = None, raise_for_status: bool = True) -&gt; Response:\n\"\"\"POST request to the backend.\n        Args:\n            endpoint (str): POST endpoint\n            data (Optional[dict]): (optional) multipart form data\n            json (Optional[dict]): (optional) json data\n            files (Optional[dict]): (optional) files to be sent\n            raise_for_status (bool): raise an exception on error\n        Returns:\n            Response object\n        \"\"\"\nurl_data = self.__build_url(endpoint, data=data, json=json, files=files)\nresponse = self._http_client.post(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\ndef get(self, endpoint: str, params: Optional[dict] = None, cookies: Optional[dict] = None, raise_for_status: bool = True) -&gt; Response:\n\"\"\"GET request to the backend.\n        Args:\n            endpoint (str): GET endpoint\n            cookies (Optional[dict]): (optional) cookies data\n            raise_for_status (bool): raise an exception on error\n        Returns:\n            Response object\n        \"\"\"\nurl_data = self.__build_url(endpoint, params=params, cookies=cookies)\nresponse = self._http_client.get(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\ndef get_static_file(self, endpoint: str, raise_for_status: bool = True) -&gt; Response:\n\"\"\"Retrieve a static file from the backend.\n        Args:\n            endpoint (str): GET endpoint\n            raise_for_status (bool): raise an exception on error\n        Returns:\n            Response object\n        \"\"\"\nurl_data = self.__build_url(endpoint)\nurl_data['url'] = f'{self._scheme}://{self._base_url}/static-content{endpoint}'\nresponse = self._http_client.get(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\ndef _handshake(self):\n\"\"\"Client handshake.\n        It is used to determine is the client can connect with its\n        current authorization token.\n        \"\"\"\nresponse = self.get('/profiles', params={}, raise_for_status=False)\nif response.status_code == Client.codes.FOUND:\nparser = LinkExtractor()\nparser.feed(response.text)\nraise ClientHandshakeError(auth_link=parser.link)\ndef _get_default_project(self, token: str):\nresponse = self.get('/profiles/me', params={}, cookies={'access_token': token})\ndata: dict = response.json()\nreturn data['myWorkspace']\ndef __build_url(self, endpoint: str, params: Optional[dict] = None, data: Optional[dict] = None, json: Optional[dict] = None, files: Optional[dict] = None, cookies: Optional[dict] = None) -&gt; dict:\n\"\"\"Build a request for the backend.\n        Args:\n            endpoint (str): backend endpoint\n            params (Optional[dict]): URL parameters\n            data (Optional[Project]): (optional) multipart form data\n            json (Optional[dict]): (optional) json data\n            files (Optional[dict]): (optional) files to be sent\n            cookies (Optional[dict]): (optional) cookies data\n        Returns:\n            dictionary containing the information to perform a request\n        \"\"\"\n_params = params if params is not None else {\n'ns': self._project\n}\nurl_data = {\n'url': f'{self._scheme}://{self._base_url}/api{endpoint}',\n'headers': self._headers,\n'params': _params,\n}\nif data is not None:\nurl_data['data'] = data\nif json is not None:\nurl_data['json'] = json\nif files is not None:\nurl_data['files'] = files\nif cookies is not None:\nurl_data['cookies'] = cookies\nreturn url_data\ndef __set_global(self) -&gt; None:\n\"\"\"Sets a client instance as global.\"\"\"\n# If the client is stateful, close it gracefully!\nClient.GLOBAL_CLIENT = self\ndef __raise_for_status(self, response: Response) -&gt; None:\n\"\"\"Raise an exception if the response is not OK.\n        When an exception is raised, we try to convert it to a ResponseError which is\n        a wrapper around a backend error. This usually gives enough context and provides\n        nice error message.\n        If it cannot be converted to ResponseError, it is re-raised.\n        Args:\n            response (Response): response to analyze\n        \"\"\"\ntry:\nresponse.raise_for_status()\nexcept HTTPStatusError as e:\nwith suppress(Exception):\ne = ResponseError(**response.json())\nraise e\n</code></pre>"},{"location":"reference/api/common/client/#ydata.sdk.common.client.client.Client.get","title":"<code>get(endpoint, params=None, cookies=None, raise_for_status=True)</code>","text":"<p>GET request to the backend.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>GET endpoint</p> required <code>cookies</code> <code>Optional[dict]</code> <p>(optional) cookies data</p> <code>None</code> <code>raise_for_status</code> <code>bool</code> <p>raise an exception on error</p> <code>True</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object</p> Source code in <code>ydata/sdk/common/client/client.py</code> <pre><code>def get(self, endpoint: str, params: Optional[dict] = None, cookies: Optional[dict] = None, raise_for_status: bool = True) -&gt; Response:\n\"\"\"GET request to the backend.\n    Args:\n        endpoint (str): GET endpoint\n        cookies (Optional[dict]): (optional) cookies data\n        raise_for_status (bool): raise an exception on error\n    Returns:\n        Response object\n    \"\"\"\nurl_data = self.__build_url(endpoint, params=params, cookies=cookies)\nresponse = self._http_client.get(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\n</code></pre>"},{"location":"reference/api/common/client/#ydata.sdk.common.client.client.Client.get_static_file","title":"<code>get_static_file(endpoint, raise_for_status=True)</code>","text":"<p>Retrieve a static file from the backend.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>GET endpoint</p> required <code>raise_for_status</code> <code>bool</code> <p>raise an exception on error</p> <code>True</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object</p> Source code in <code>ydata/sdk/common/client/client.py</code> <pre><code>def get_static_file(self, endpoint: str, raise_for_status: bool = True) -&gt; Response:\n\"\"\"Retrieve a static file from the backend.\n    Args:\n        endpoint (str): GET endpoint\n        raise_for_status (bool): raise an exception on error\n    Returns:\n        Response object\n    \"\"\"\nurl_data = self.__build_url(endpoint)\nurl_data['url'] = f'{self._scheme}://{self._base_url}/static-content{endpoint}'\nresponse = self._http_client.get(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\n</code></pre>"},{"location":"reference/api/common/client/#ydata.sdk.common.client.client.Client.post","title":"<code>post(endpoint, data=None, json=None, files=None, raise_for_status=True)</code>","text":"<p>POST request to the backend.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>POST endpoint</p> required <code>data</code> <code>Optional[dict]</code> <p>(optional) multipart form data</p> <code>None</code> <code>json</code> <code>Optional[dict]</code> <p>(optional) json data</p> <code>None</code> <code>files</code> <code>Optional[dict]</code> <p>(optional) files to be sent</p> <code>None</code> <code>raise_for_status</code> <code>bool</code> <p>raise an exception on error</p> <code>True</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object</p> Source code in <code>ydata/sdk/common/client/client.py</code> <pre><code>def post(self, endpoint: str, data: Optional[dict] = None, json: Optional[dict] = None, files: Optional[dict] = None, raise_for_status: bool = True) -&gt; Response:\n\"\"\"POST request to the backend.\n    Args:\n        endpoint (str): POST endpoint\n        data (Optional[dict]): (optional) multipart form data\n        json (Optional[dict]): (optional) json data\n        files (Optional[dict]): (optional) files to be sent\n        raise_for_status (bool): raise an exception on error\n    Returns:\n        Response object\n    \"\"\"\nurl_data = self.__build_url(endpoint, data=data, json=json, files=files)\nresponse = self._http_client.post(**url_data)\nif response.status_code != Client.codes.OK and raise_for_status:\nself.__raise_for_status(response)\nreturn response\n</code></pre>"},{"location":"reference/api/common/types/","title":"Types","text":""},{"location":"reference/api/connectors/connector/","title":"Connector","text":"<p>         Bases: <code>ModelFactoryMixin</code></p> <p>A <code>Connector</code> allows to connect and access data stored in various places. The list of available connectors can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>connector_type</code> <code>Union[ConnectorType, str]</code> <p>Type of the connector to be created</p> <code>None</code> <code>credentials</code> <code>dict</code> <p>Connector credentials</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>(optional) Connector name</p> <code>None</code> <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>uid</code> <code>UID</code> <p>UID fo the connector instance (creating internally)</p> <code>type</code> <code>ConnectorType</code> <p>Type of the connector</p> Source code in <code>ydata/sdk/connectors/connector.py</code> <pre><code>class Connector(ModelFactoryMixin):\n\"\"\"A [`Connector`][ydata.sdk.connectors.Connector] allows to connect and\n    access data stored in various places. The list of available connectors can\n    be found [here][ydata.sdk.connectors.ConnectorType].\n    Arguments:\n        connector_type (Union[ConnectorType, str]): Type of the connector to be created\n        credentials (dict): Connector credentials\n        name (Optional[str]): (optional) Connector name\n        client (Client): (optional) Client to connect to the backend\n    Attributes:\n        uid (UID): UID fo the connector instance (creating internally)\n        type (ConnectorType): Type of the connector\n    \"\"\"\ndef __init__(self, connector_type: Union[ConnectorType, str] = None, credentials: Optional[dict] = None,  name: Optional[str] = None, client: Optional[Client] = None):\nself._init_common(client=client)\nself._model: Optional[mConnector] = self._create_model(\nconnector_type, credentials, name, client=client)\n@init_client\ndef _init_common(self, client: Optional[Client] = None):\nself._client = client\nself._logger = create_logger(__name__, level=LOG_LEVEL)\n@property\ndef uid(self) -&gt; UID:\nreturn self._model.uid\n@property\ndef type(self) -&gt; str:\nreturn self._model.type\n@staticmethod\n@init_client\ndef get(uid: UID, client: Optional[Client] = None) -&gt; \"Connector\":\n\"\"\"Get an existing connector.\n        Arguments:\n            uid (UID): Connector identifier\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            Connector\n        \"\"\"\nconnectors: ConnectorsList = Connector.list(client=client)\ndata = connectors.get_by_uid(uid)\nmodel = mConnector(**data)\nconnector = ModelFactoryMixin._init_from_model_data(Connector, model)\nreturn connector\n@staticmethod\ndef _init_connector_type(connector_type: Union[ConnectorType, str]) -&gt; ConnectorType:\nif isinstance(connector_type, str):\ntry:\nconnector_type = ConnectorType(connector_type)\nexcept Exception:\nc_list = \", \".join([c.value for c in ConnectorType])\nraise InvalidConnectorError(\nf\"ConnectorType '{connector_type}' does not exist.\\nValid connector types are: {c_list}.\")\nreturn connector_type\n@staticmethod\ndef _init_credentials(connector_type: ConnectorType, credentials: Union[str, Path, dict, Credentials]) -&gt; Credentials:\n_credentials = None\nif isinstance(credentials, str):\ncredentials = Path(credentials)\nif isinstance(credentials, Path):\ntry:\n_credentials = json_loads(credentials.open().read())\nexcept Exception:\nraise CredentialTypeError(\n'Could not read the credentials. Please, check your path or credentials structure.')\ntry:\nfrom ydata.sdk.connectors._models.connector_map import TYPE_TO_CLASS\ncredential_cls = TYPE_TO_CLASS.get(connector_type.value)\n_credentials = credential_cls(**_credentials)\nexcept Exception:\nraise CredentialTypeError(\n\"Could not create the credentials. Verify the path or the structure your credentials.\")\nreturn _credentials\n@staticmethod\ndef create(connector_type: Union[ConnectorType, str], credentials: Union[str, Path, dict, Credentials], name: Optional[str] = None, client: Optional[Client] = None) -&gt; \"Connector\":\n\"\"\"Create a new connector.\n        Arguments:\n            connector_type (Union[ConnectorType, str]): Type of the connector to be created\n            credentials (dict): Connector credentials\n            name (Optional[str]): (optional) Connector name\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            New connector\n        \"\"\"\nmodel = Connector._create_model(\nconnector_type=connector_type, credentials=credentials, name=name, client=client)\nconnector = ModelFactoryMixin._init_from_model_data(\nConnector, model)\nreturn connector\n@classmethod\n@init_client\ndef _create_model(cls, connector_type: Union[ConnectorType, str], credentials: Union[str, Path, dict, Credentials], name: Optional[str] = None, client: Optional[Client] = None) -&gt; mConnector:\n_name = name if name is not None else str(uuid4())\n_connector_type = Connector._init_connector_type(connector_type)\n_credentials = Connector._init_credentials(_connector_type, credentials)\npayload = {\n\"type\": _connector_type.value,\n\"credentials\": _credentials.dict(by_alias=True),\n\"name\": _name\n}\nresponse = client.post('/connector/', json=payload)\ndata: list = response.json()\nreturn mConnector(**data)\n@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; ConnectorsList:\n\"\"\"List the connectors instances.\n        Arguments:\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            List of connectors\n        \"\"\"\nresponse = client.get('/connector')\ndata: list = response.json()\nreturn ConnectorsList(data)\ndef __repr__(self):\nreturn self._model.__repr__()\n</code></pre>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors.connector.Connector.create","title":"<code>create(connector_type, credentials, name=None, client=None)</code>  <code>staticmethod</code>","text":"<p>Create a new connector.</p> <p>Parameters:</p> Name Type Description Default <code>connector_type</code> <code>Union[ConnectorType, str]</code> <p>Type of the connector to be created</p> required <code>credentials</code> <code>dict</code> <p>Connector credentials</p> required <code>name</code> <code>Optional[str]</code> <p>(optional) Connector name</p> <code>None</code> <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>Connector</code> <p>New connector</p> Source code in <code>ydata/sdk/connectors/connector.py</code> <pre><code>@staticmethod\ndef create(connector_type: Union[ConnectorType, str], credentials: Union[str, Path, dict, Credentials], name: Optional[str] = None, client: Optional[Client] = None) -&gt; \"Connector\":\n\"\"\"Create a new connector.\n    Arguments:\n        connector_type (Union[ConnectorType, str]): Type of the connector to be created\n        credentials (dict): Connector credentials\n        name (Optional[str]): (optional) Connector name\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        New connector\n    \"\"\"\nmodel = Connector._create_model(\nconnector_type=connector_type, credentials=credentials, name=name, client=client)\nconnector = ModelFactoryMixin._init_from_model_data(\nConnector, model)\nreturn connector\n</code></pre>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors.connector.Connector.get","title":"<code>get(uid, client=None)</code>  <code>staticmethod</code>","text":"<p>Get an existing connector.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UID</code> <p>Connector identifier</p> required <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>Connector</code> <p>Connector</p> Source code in <code>ydata/sdk/connectors/connector.py</code> <pre><code>@staticmethod\n@init_client\ndef get(uid: UID, client: Optional[Client] = None) -&gt; \"Connector\":\n\"\"\"Get an existing connector.\n    Arguments:\n        uid (UID): Connector identifier\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        Connector\n    \"\"\"\nconnectors: ConnectorsList = Connector.list(client=client)\ndata = connectors.get_by_uid(uid)\nmodel = mConnector(**data)\nconnector = ModelFactoryMixin._init_from_model_data(Connector, model)\nreturn connector\n</code></pre>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors.connector.Connector.list","title":"<code>list(client=None)</code>  <code>staticmethod</code>","text":"<p>List the connectors instances.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>ConnectorsList</code> <p>List of connectors</p> Source code in <code>ydata/sdk/connectors/connector.py</code> <pre><code>@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; ConnectorsList:\n\"\"\"List the connectors instances.\n    Arguments:\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        List of connectors\n    \"\"\"\nresponse = client.get('/connector')\ndata: list = response.json()\nreturn ConnectorsList(data)\n</code></pre>"},{"location":"reference/api/connectors/connector/#connectortype","title":"ConnectorType","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.AWS_S3","title":"<code>AWS_S3 = 'aws-s3'</code>  <code>class-attribute</code>","text":"<p>AWS S3 connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.AZURE_BLOB","title":"<code>AZURE_BLOB = 'azure-blob'</code>  <code>class-attribute</code>","text":"<p>Azure Blob connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.AZURE_SQL","title":"<code>AZURE_SQL = 'azure-sql'</code>  <code>class-attribute</code>","text":"<p>AzureSQL connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.BIGQUERY","title":"<code>BIGQUERY = 'google-bigquery'</code>  <code>class-attribute</code>","text":"<p>BigQuery connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.FILE","title":"<code>FILE = 'file'</code>  <code>class-attribute</code>","text":"<p>File connector (placeholder)</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.GCS","title":"<code>GCS = 'gcs'</code>  <code>class-attribute</code>","text":"<p>Google Cloud Storage connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.MYSQL","title":"<code>MYSQL = 'mysql'</code>  <code>class-attribute</code>","text":"<p>MySQL connector</p>"},{"location":"reference/api/connectors/connector/#ydata.sdk.connectors._models.connector_type.ConnectorType.SNOWFLAKE","title":"<code>SNOWFLAKE = 'snowflake'</code>  <code>class-attribute</code>","text":"<p>Snowflake connector</p>"},{"location":"reference/api/datasources/attributes/","title":"DataSourceAttrs","text":"<p>         Bases: <code>BaseModel</code></p> <p><code>DataSourceAttrs</code> are used to configure a <code>Synthesizer</code> fitting process.</p> <p>Whenever a <code>DataSourceAttrs</code> is required, a <code>dict</code> can be provided instead. All arguments are optional except <code>sortbykey</code> that needs to be provided for <code>TimeSeries</code> <code>DataSource</code>.</p> <p>By default, if <code>generate_cols</code> or <code>exclude_cols</code> are not specified, all columns are generated by the synthesizer. The argument <code>exclude_cols</code> has precedence over <code>generate_cols</code>, i.e. a column <code>col</code> will not be generated if it is in both list.</p> <p>Attributes:</p> Name Type Description <code>sortbykey</code> <code>Union[str, List[str]]</code> <p>(optional) column(s) to use to sort timeseries datasets</p> <code>entity_id_cols</code> <code>Union[str, List[str]]</code> <p>(optional) columns representing entities ID</p> <code>generate_cols</code> <code>List[str]</code> <p>(optional) columns that should be synthesized</p> <code>exclude_cols</code> <code>List[str]</code> <p>(optional) columns that should not be synthesized</p> Source code in <code>ydata/sdk/datasources/_models/attributes.py</code> <pre><code>class DataSourceAttrs(BaseModel):\n\"\"\"[`DataSourceAttrs`][ydata.sdk.datasources.DataSourceAttrs] are used to\n    configure a [`Synthesizer`][ydata.sdk.synthesizers.Synthesizer] fitting\n    process.\n    Whenever a [`DataSourceAttrs`][ydata.sdk.datasources.DataSourceAttrs] is required, a `dict` can be provided instead.\n    All arguments are optional except `sortbykey` that needs to be provided for [`TimeSeries`][ydata.sdk.datasources.datasource.DataSourceType.TIMESERIES] [`DataSource`][ydata.sdk.datasources.datasource.DataSource].\n    By default, if `generate_cols` or `exclude_cols` are not specified, all columns are generated by the synthesizer.\n    The argument `exclude_cols` has precedence over `generate_cols`, i.e. a column `col` will not be generated if it is in both list.\n    Attributes:\n        sortbykey (Union[str, List[str]]): (optional) column(s) to use to sort timeseries datasets\n        entity_id_cols (Union[str, List[str]]): (optional) columns representing entities ID\n        generate_cols (List[str]): (optional) columns that should be synthesized\n        exclude_cols (List[str]): (optional) columns that should not be synthesized\n    \"\"\"\nsortbykey: Union[str, List[str]] = Field(default_factory=list)\nentity_id_cols: Union[str, List[str]] = Field(default_factory=list)\ngenerate_cols: List[str] = Field(default_factory=list)\nexclude_cols: List[str] = Field(default_factory=list)\ndef __init__(self, **fields):\nsortbykey = fields.get(\"sortbykey\")\nif sortbykey is not None and isinstance(sortbykey, str):\nfields['sortbykey'] = [sortbykey]\nentity_id_cols = fields.get(\"entity_id_cols\")\nif entity_id_cols is not None and isinstance(entity_id_cols, str):\nfields['entity_id_cols'] = [entity_id_cols]\nsuper().__init__(**fields)\n</code></pre>"},{"location":"reference/api/datasources/datasource/","title":"DataSource","text":"<p>         Bases: <code>ModelFactoryMixin</code></p> <p>A <code>DataSource</code> represents a dataset to be used by a Synthesizer as training data.</p> <p>Parameters:</p> Name Type Description Default <code>connector</code> <code>Connector</code> <p>Connector from which the datasource is created</p> required <code>datatype</code> <code>Optional[Union[DataSourceType, str]]</code> <p>(optional) DataSource type</p> <code>DataSourceType.TABULAR</code> <code>name</code> <code>Optional[str]</code> <p>(optional) DataSource name</p> <code>None</code> <code>wait_for_metadata</code> <code>bool</code> <p>If <code>True</code>, wait until the metadata is fully calculated</p> <code>True</code> <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <code>**config</code> <p>Datasource specific configuration</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>uid</code> <code>UID</code> <p>UID fo the datasource instance</p> <code>datatype</code> <code>DataSourceType</code> <p>Data source type</p> <code>status</code> <code>Status</code> <p>Status of the datasource</p> <code>metadata</code> <code>Metadata</code> <p>Metadata associated to the datasource</p> Source code in <code>ydata/sdk/datasources/datasource.py</code> <pre><code>class DataSource(ModelFactoryMixin):\n\"\"\"A [`DataSource`][ydata.sdk.datasources.DataSource] represents a dataset\n    to be used by a Synthesizer as training data.\n    Arguments:\n        connector (Connector): Connector from which the datasource is created\n        datatype (Optional[Union[DataSourceType, str]]): (optional) DataSource type\n        name (Optional[str]): (optional) DataSource name\n        wait_for_metadata (bool): If `True`, wait until the metadata is fully calculated\n        client (Client): (optional) Client to connect to the backend\n        **config: Datasource specific configuration\n    Attributes:\n        uid (UID): UID fo the datasource instance\n        datatype (DataSourceType): Data source type\n        status (Status): Status of the datasource\n        metadata (Metadata): Metadata associated to the datasource\n    \"\"\"\ndef __init__(self, connector: Connector, datatype: Optional[Union[DataSourceType, str]] = DataSourceType.TABULAR, name: Optional[str] = None, wait_for_metadata: bool = True, client: Optional[Client] = None, **config):\ndatasource_type = CONNECTOR_TO_DADASOURCE.get(connector.type)\nself._init_common(client=client)\nself._model: Optional[mDataSource] = self._create_model(\nconnector=connector, datasource_type=datasource_type, datatype=datatype, config=config, name=name, client=self._client)\nif wait_for_metadata:\nself._model = DataSource._wait_for_metadata(self)._model\n@init_client\ndef _init_common(self, client: Optional[Client] = None):\nself._client = client\nself._logger = create_logger(__name__, level=LOG_LEVEL)\n@property\ndef uid(self) -&gt; UID:\nreturn self._model.uid\n@property\ndef datatype(self) -&gt; DataSourceType:\nreturn self._model.datatype\n@property\ndef status(self) -&gt; Status:\ntry:\nself._model = self.get(self._model.uid, self._client)._model\nreturn self._model.status\nexcept Exception:  # noqa: PIE786\nreturn Status.UNKNOWN\n@property\ndef metadata(self) -&gt; Metadata:\nreturn self._model.metadata\n@staticmethod\ndef _create_payload(*_) -&gt; dict:\nreturn {}\n@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; DataSourceList:\n\"\"\"List the  [`DataSource`][ydata.sdk.datasources.DataSource]\n        instances.\n        Arguments:\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            List of datasources\n        \"\"\"\ndef __process_data(data: list) -&gt; list:\nto_del = ['metadata']\nfor e in data:\nfor k in to_del:\ne.pop(k, None)\nreturn data\nresponse = client.get('/datasource')\ndata: list = response.json()\ndata = __process_data(data)\nreturn DataSourceList(data)\n@staticmethod\n@init_client\ndef get(uid: UID, client: Optional[Client] = None) -&gt; \"DataSource\":\n\"\"\"Get an existing [`DataSource`][ydata.sdk.datasources.DataSource].\n        Arguments:\n            uid (UID): DataSource identifier\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            DataSource\n        \"\"\"\nresponse = client.get(f'/datasource/{uid}')\ndata: list = response.json()\ndatasource_type = CONNECTOR_TO_DADASOURCE.get(\nConnectorType(data['connector']['type']))\nmodel = DataSource._model_from_api(data, datasource_type)\ndatasource = ModelFactoryMixin._init_from_model_data(DataSource, model)\nreturn datasource\n@classmethod\ndef create(cls, connector: Connector, datatype: Optional[Union[DataSourceType, str]] = DataSourceType.TABULAR, name: Optional[str] = None, wait_for_metadata: bool = True, client: Optional[Client] = None, **config) -&gt; \"DataSource\":\n\"\"\"Create a new [`DataSource`][ydata.sdk.datasources.DataSource].\n        Arguments:\n            connector (Connector): Connector from which the datasource is created\n            datatype (Optional[Union[DataSourceType, str]]): (optional) DataSource type\n            name (Optional[str]): (optional) DataSource name\n            wait_for_metadata (bool): If `True`, wait until the metadata is fully calculated\n            client (Client): (optional) Client to connect to the backend\n            **config: Datasource specific configuration\n        Returns:\n            DataSource\n        \"\"\"\ndatasource_type = CONNECTOR_TO_DADASOURCE.get(connector.type)\nreturn cls._create(connector=connector, datasource_type=datasource_type, datatype=datatype, config=config, name=name, wait_for_metadata=wait_for_metadata, client=client)\n@classmethod\ndef _create(cls, connector: Connector, datasource_type: Type[mDataSource], datatype: Optional[Union[DataSourceType, str]] = DataSourceType.TABULAR, config: Optional[dict] = None, name: Optional[str] = None, wait_for_metadata: bool = True, client: Optional[Client] = None) -&gt; \"DataSource\":\nmodel = DataSource._create_model(\nconnector, datasource_type, datatype, config, name, client)\ndatasource = ModelFactoryMixin._init_from_model_data(DataSource, model)\nif wait_for_metadata:\ndatasource._model = DataSource._wait_for_metadata(datasource)._model\nreturn datasource\n@classmethod\n@init_client\ndef _create_model(cls, connector: Connector, datasource_type: Type[mDataSource], datatype: Optional[Union[DataSourceType, str]] = DataSourceType.TABULAR, config: Optional[dict] = None, name: Optional[str] = None, client: Optional[Client] = None) -&gt; mDataSource:\n_name = name if name is not None else str(uuid4())\n_config = config if config is not None else {}\npayload = {\n\"name\": _name,\n\"connector\": {\n\"uid\": connector.uid,\n\"type\": connector.type.value\n},\n\"dataType\": datatype.value\n}\nif connector.type != ConnectorType.FILE:\n_config = datasource_type(**config).to_payload()\npayload.update(_config)\nresponse = client.post('/datasource/', json=payload)\ndata: list = response.json()\nreturn DataSource._model_from_api(data, datasource_type)\n@staticmethod\ndef _wait_for_metadata(datasource):\nlogger = create_logger(__name__, level=LOG_LEVEL)\nwhile datasource.status not in [Status.AVAILABLE, Status.FAILED, Status.UNAVAILABLE]:\nlogger.info(f'Calculating metadata [{datasource.status}]')\ndatasource = DataSource.get(uid=datasource.uid, client=datasource._client)\nsleep(BACKOFF)\nreturn datasource\n@staticmethod\ndef _resolve_api_status(api_status: dict) -&gt; Status:\nstatus = Status(api_status.get('state', Status.UNKNOWN.name))\nvalidation = ValidationState(api_status.get('validation', {}).get(\n'state', ValidationState.UNKNOWN.name))\nif validation == ValidationState.FAILED:\nstatus = Status.FAILED\nreturn status\n@staticmethod\ndef _model_from_api(data: dict, datasource_type: Type[mDataSource]) -&gt; mDataSource:\ndata['datatype'] = data.pop('dataType')\ndata['state'] = data['status']\ndata['status'] = DataSource._resolve_api_status(data['status'])\ndata = filter_dict(datasource_type, data)\nmodel = datasource_type(**data)\nreturn model\ndef __repr__(self):\nreturn self._model.__repr__()\n</code></pre>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources.datasource.DataSource.create","title":"<code>create(connector, datatype=DataSourceType.TABULAR, name=None, wait_for_metadata=True, client=None, **config)</code>  <code>classmethod</code>","text":"<p>Create a new <code>DataSource</code>.</p> <p>Parameters:</p> Name Type Description Default <code>connector</code> <code>Connector</code> <p>Connector from which the datasource is created</p> required <code>datatype</code> <code>Optional[Union[DataSourceType, str]]</code> <p>(optional) DataSource type</p> <code>DataSourceType.TABULAR</code> <code>name</code> <code>Optional[str]</code> <p>(optional) DataSource name</p> <code>None</code> <code>wait_for_metadata</code> <code>bool</code> <p>If <code>True</code>, wait until the metadata is fully calculated</p> <code>True</code> <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <code>**config</code> <p>Datasource specific configuration</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataSource</code> <p>DataSource</p> Source code in <code>ydata/sdk/datasources/datasource.py</code> <pre><code>@classmethod\ndef create(cls, connector: Connector, datatype: Optional[Union[DataSourceType, str]] = DataSourceType.TABULAR, name: Optional[str] = None, wait_for_metadata: bool = True, client: Optional[Client] = None, **config) -&gt; \"DataSource\":\n\"\"\"Create a new [`DataSource`][ydata.sdk.datasources.DataSource].\n    Arguments:\n        connector (Connector): Connector from which the datasource is created\n        datatype (Optional[Union[DataSourceType, str]]): (optional) DataSource type\n        name (Optional[str]): (optional) DataSource name\n        wait_for_metadata (bool): If `True`, wait until the metadata is fully calculated\n        client (Client): (optional) Client to connect to the backend\n        **config: Datasource specific configuration\n    Returns:\n        DataSource\n    \"\"\"\ndatasource_type = CONNECTOR_TO_DADASOURCE.get(connector.type)\nreturn cls._create(connector=connector, datasource_type=datasource_type, datatype=datatype, config=config, name=name, wait_for_metadata=wait_for_metadata, client=client)\n</code></pre>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources.datasource.DataSource.get","title":"<code>get(uid, client=None)</code>  <code>staticmethod</code>","text":"<p>Get an existing <code>DataSource</code>.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UID</code> <p>DataSource identifier</p> required <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>DataSource</code> <p>DataSource</p> Source code in <code>ydata/sdk/datasources/datasource.py</code> <pre><code>@staticmethod\n@init_client\ndef get(uid: UID, client: Optional[Client] = None) -&gt; \"DataSource\":\n\"\"\"Get an existing [`DataSource`][ydata.sdk.datasources.DataSource].\n    Arguments:\n        uid (UID): DataSource identifier\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        DataSource\n    \"\"\"\nresponse = client.get(f'/datasource/{uid}')\ndata: list = response.json()\ndatasource_type = CONNECTOR_TO_DADASOURCE.get(\nConnectorType(data['connector']['type']))\nmodel = DataSource._model_from_api(data, datasource_type)\ndatasource = ModelFactoryMixin._init_from_model_data(DataSource, model)\nreturn datasource\n</code></pre>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources.datasource.DataSource.list","title":"<code>list(client=None)</code>  <code>staticmethod</code>","text":"<p>List the  <code>DataSource</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>DataSourceList</code> <p>List of datasources</p> Source code in <code>ydata/sdk/datasources/datasource.py</code> <pre><code>@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; DataSourceList:\n\"\"\"List the  [`DataSource`][ydata.sdk.datasources.DataSource]\n    instances.\n    Arguments:\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        List of datasources\n    \"\"\"\ndef __process_data(data: list) -&gt; list:\nto_del = ['metadata']\nfor e in data:\nfor k in to_del:\ne.pop(k, None)\nreturn data\nresponse = client.get('/datasource')\ndata: list = response.json()\ndata = __process_data(data)\nreturn DataSourceList(data)\n</code></pre>"},{"location":"reference/api/datasources/datasource/#status","title":"Status","text":"<p>         Bases: <code>StringEnum</code></p> <p>Represent the status of a <code>DataSource</code>.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.AVAILABLE","title":"<code>AVAILABLE = 'available'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is available and ready to be used.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.DELETED","title":"<code>DELETED = 'deleted'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is to be deleted or has been deleted.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.FAILED","title":"<code>FAILED = 'failed'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> preparation or validation has failed.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.PREPARING","title":"<code>PREPARING = 'preparing'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is being prepared.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.UNAVAILABLE","title":"<code>UNAVAILABLE = 'unavailable'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is unavailable at the moment.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.UNKNOWN","title":"<code>UNKNOWN = 'unknown'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> status could not be retrieved.</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.status.Status.VALIDATING","title":"<code>VALIDATING = 'validating'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is being validated.</p>"},{"location":"reference/api/datasources/datasource/#datasourcetype","title":"DataSourceType","text":"<p>         Bases: <code>StringEnum</code></p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.datatype.DataSourceType.TABULAR","title":"<code>TABULAR = 'tabular'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> is tabular (i.e. it does not have a temporal dimension).</p>"},{"location":"reference/api/datasources/datasource/#ydata.sdk.datasources._models.datatype.DataSourceType.TIMESERIES","title":"<code>TIMESERIES = 'timeseries'</code>  <code>class-attribute</code>","text":"<p>The <code>DataSource</code> has a temporal dimension.</p>"},{"location":"reference/api/datasources/metadata/","title":"Metadata","text":"<p>         Bases: <code>BaseModel</code></p> <p>The Metadata object contains descriptive information about a.</p> <p><code>DataSource</code></p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[Column]</code> <p>columns information</p>"},{"location":"reference/api/synthesizers/base/","title":"Synthesizer","text":"<p>         Bases: <code>ABC</code>, <code>ModelFactoryMixin</code></p> <p>Main synthesizer class.</p> <p>This class cannot be directly instanciated because of the specificities between <code>RegularSynthesizer</code> and <code>TimeSeriesSynthesizer</code> <code>sample</code> methods.</p>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer--methods","title":"Methods","text":"<ul> <li><code>fit</code>: train a synthesizer instance.</li> <li><code>sample</code>: request synthetic data.</li> <li><code>status</code>: current status of the synthesizer instance.</li> </ul> Note <p>The synthesizer instance is created in the backend only when the <code>fit</code> method is called.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> Source code in <code>ydata/sdk/synthesizers/synthesizer.py</code> <pre><code>@typechecked\nclass BaseSynthesizer(ABC, ModelFactoryMixin):\n\"\"\"Main synthesizer class.\n    This class cannot be directly instanciated because of the specificities between [`RegularSynthesizer`][ydata.sdk.synthesizers.RegularSynthesizer] and [`TimeSeriesSynthesizer`][ydata.sdk.synthesizers.TimeSeriesSynthesizer] `sample` methods.\n    Methods\n    -------\n    - `fit`: train a synthesizer instance.\n    - `sample`: request synthetic data.\n    - `status`: current status of the synthesizer instance.\n    Note:\n            The synthesizer instance is created in the backend only when the `fit` method is called.\n    Arguments:\n        client (Client): (optional) Client to connect to the backend\n    \"\"\"\ndef __init__(self, client: Optional[Client] = None):\nself._init_common(client=client)\nself._model: Optional[mSynthesizer] = None\n@init_client\ndef _init_common(self, client: Optional[Client] = None):\nself._client = client\nself._logger = create_logger(__name__, level=LOG_LEVEL)\ndef fit(self, X: Union[DataSource, pdDataFrame], datatype: Optional[Union[DataSourceType, str]] = None, dataset_attrs: Optional[Union[DataSourceAttrs, dict]] = None, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n        The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n        When the training dataset is a pandas [`DataFrame`][pandas.DataFrame], the argument `datatype` is required as it cannot be deduced.\n        Similarly, `dataset_attrs` is mandatory for [`TimeSeries`][ydata.sdk.datasources.DataSourceType.TIMESERIES] dataset to specify the `sortbykey` columns.\n        Arguments:\n            X (Union[DataSource, pandas.DataFrame]): Training dataset\n            datatype (Optional[Union[DataSourceType, str]]): (optional) Dataset datatype - required if `X` is a [`pandas.DataFrame`][pandas.DataFrame]\n            dataset_attrs (Optional[Union[DataSourceAttrs, dict]]): (optional) Dataset attributes\n            target (Optional[str]): (optional) Metadata associated to the datasource\n            name (Optional[str]): (optional) Synthesizer instance name\n        \"\"\"\nif self._is_initialized():\nraise AlreadyFittedError()\n_datatype = DataSourceType(datatype) if isinstance(\nX, pdDataFrame) else DataSourceType(X.datatype)\ndataset_attrs = dataset_attrs if dataset_attrs is not None else {}\nif isinstance(dataset_attrs, dict):\ndataset_attrs = DataSourceAttrs(**dataset_attrs)\nself._validate_datasource_attributes(X, dataset_attrs, _datatype, target)\n# If the training data is a pandas dataframe, we first need to create a data source and then the instance\nif isinstance(X, pdDataFrame):\n_X = LocalDataSource(source=X, datatype=_datatype, client=self._client)\nelse:\nif datatype is not None:\nwarn(\"When the training data is a DataSource, the argument `datatype` is ignored.\",\nDataSourceTypeWarning)\n_X = X\nif _X.status != dsStatus.AVAILABLE:\nraise DataSourceNotAvailableError(\nf\"The datasource '{_X.uid}' is not available (status = {_X.status.value})\")\nif isinstance(dataset_attrs, dict):\ndataset_attrs = DataSourceAttrs(**dataset_attrs)\nself._fit_from_datasource(\nX=_X, dataset_attrs=dataset_attrs, target=target, name=name)\n@staticmethod\ndef _validate_datasource_attributes(X: Union[DataSource, pdDataFrame], dataset_attrs: DataSourceAttrs, datatype: DataSourceType, target: Optional[str]):\ncolumns = []\nif isinstance(X, pdDataFrame):\ncolumns = X.columns\nif datatype is None:\nraise DataTypeMissingError(\n\"Argument `datatype` is mandatory for pandas.DataFrame training data\")\ndatatype = DataSourceType(datatype)\nelse:\ncolumns = [c.name for c in X.metadata.columns]\nif target is not None and target not in columns:\nraise DataSourceAttrsError(\n\"Invalid target: column '{target}' does not exist\")\nif datatype == DataSourceType.TIMESERIES:\nif dataset_attrs is None:\nraise DataSourceAttrsError(\n\"The argument `dataset_attrs` is mandatory for timeseries datasource. The attributes must define at least one column in `sortbykey` attribute.\")\ninvalid_fields = {}\nfor field, v in dataset_attrs.dict().items():\nnot_in_cols = [c for c in v if c not in columns]\nif len(not_in_cols) &gt; 0:\ninvalid_fields[field] = not_in_cols\nif len(invalid_fields) &gt; 0:\nerror_msgs = [\"\\t- Field '{}': columns {} do not exist\".format(\nf, ''.join(v)) for f, v in invalid_fields.items()]\nraise DataSourceAttrsError(\n\"The dataset attributes are invalid: {}\".format('\\n'.join(error_msgs)))\n@staticmethod\ndef _metadata_to_payload(datatype: DataSourceType, ds_metadata: Metadata, dataset_attrs: Optional[DataSourceAttrs] = None) -&gt; list:\n\"\"\"Transform a the metadata and dataset attributes into a valid\n        payload.\n        Arguments:\n            datatype (DataSourceType): datasource type\n            ds_metadata (Metadata): datasource metadata object\n            dataset_attrs ( Optional[DataSourceAttrs] ): (optional) Dataset attributes\n        Returns:\n            payload dictionary\n        \"\"\"\ncolumns = {}\nfor c in ds_metadata.columns:\ncolumns[c.name] = {\n'name': c.name,\n'generation': True,\n'dataType': c.datatype,\n'varType': c.vartype,\n'entity': False,\n}\nif dataset_attrs is not None:\nif datatype == DataSourceType.TIMESERIES:\nfor c in ds_metadata.columns:\ncolumns[c.name]['sortBy'] = c.name in dataset_attrs.sortbykey\nfor c in dataset_attrs.entity_id_cols:\ncolumns[c]['entity'] = True\nfor c in dataset_attrs.generate_cols:\ncolumns[c]['generation'] = True\nfor c in dataset_attrs.exclude_cols:\ncolumns[c]['generation'] = False\nreturn list(columns.values())\ndef _fit_from_datasource(self, X: DataSource, dataset_attrs: Optional[DataSourceAttrs] = None, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n_name = name if name is not None else str(uuid4())\ncolumns = self._metadata_to_payload(\nDataSourceType(X.datatype), X.metadata, dataset_attrs)\npayload = {\n'name': _name,\n'dataSourceUID': X.uid,\n'metadata': {\n'dataType': X.datatype,\n\"columns\": columns,\n},\n}\nif target is not None:\npayload['metadata']['target'] = target\nresponse = self._client.post('/synthesizer/', json=payload)\ndata: list = response.json()\nself._model, _ = self._model_from_api(X.datatype, data)\nwhile self.status not in [Status.READY, Status.FAILED]:\nself._logger.info('Training the synthesizer...')\nsleep(BACKOFF)\nif self.status == Status.FAILED:\nraise FittingError('Could not train the synthesizer')\n@staticmethod\ndef _model_from_api(datatype: str, data: dict) -&gt; Tuple[mSynthesizer, Type[\"BaseSynthesizer\"]]:\nfrom ydata.sdk.synthesizers._models.synthesizer_map import TYPE_TO_CLASS\nsynth_cls = TYPE_TO_CLASS.get(SynthesizerType(datatype).value)\ndata['status'] = synth_cls._resolve_api_status(data['status'])\ndata = filter_dict(mSynthesizer, data)\nreturn mSynthesizer(**data), synth_cls\n@abstractmethod\ndef sample(self) -&gt; pdDataFrame:\n\"\"\"Abstract method to sample from a synthesizer.\"\"\"\ndef _sample(self, payload: dict) -&gt; pdDataFrame:\n\"\"\"Sample from a synthesizer.\n        Arguments:\n            payload (dict): payload configuring the sample request\n        Returns:\n            pandas `DataFrame`\n        \"\"\"\nresponse = self._client.post(\nf\"/synthesizer/{self.uid}/sample\", json=payload)\ndata: dict = response.json()\nsample_uid = data.get('uid')\nsample_status = None\nwhile sample_status not in ['finished', 'failed']:\nself._logger.info('Sampling from the synthesizer...')\nresponse = self._client.get(f'/synthesizer/{self.uid}/history')\nhistory: dict = response.json()\nsample_data = next((s for s in history if s.get('uid') == sample_uid), None)\nsample_status = sample_data['state']\nsleep(BACKOFF)\nresponse = self._client.get_static_file(\nf'/synthesizer/{self.uid}/sample/{sample_uid}/sample.csv')\ndata = StringIO(response.content.decode())\nreturn read_csv(data)\n@property\ndef uid(self) -&gt; UID:\n\"\"\"Get the status of a synthesizer instance.\n        Returns:\n            Synthesizer status\n        \"\"\"\nif not self._is_initialized():\nreturn Status.NOT_INITIALIZED\nreturn self._model.uid\n@property\ndef status(self) -&gt; Status:\n\"\"\"Get the status of a synthesizer instance.\n        Returns:\n            Synthesizer status\n        \"\"\"\nif not self._is_initialized():\nreturn Status.NOT_INITIALIZED\ntry:\nself = self.get(self._model.uid, self._client)\nreturn self._model.status\nexcept Exception:  # noqa: PIE786\nreturn Status.UNKNOWN\n@staticmethod\n@init_client\ndef get(uid: str, client: Optional[Client] = None) -&gt; \"BaseSynthesizer\":\n\"\"\"List the synthesizer instances.\n        Arguments:\n            uid (str): synthesizer instance uid\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            Synthesizer instance\n        \"\"\"\nresponse = client.get(f'/synthesizer/{uid}')\ndata: list = response.json()\nmodel, synth_cls = BaseSynthesizer._model_from_api(\ndata['dataSource']['dataType'], data)\nreturn ModelFactoryMixin._init_from_model_data(synth_cls, model)\n@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; SynthesizersList:\n\"\"\"List the synthesizer instances.\n        Arguments:\n            client (Client): (optional) Client to connect to the backend\n        Returns:\n            List of synthesizers\n        \"\"\"\ndef __process_data(data: list) -&gt; list:\nto_del = ['metadata', 'report', 'mode']\nfor e in data:\nfor k in to_del:\ne.pop(k, None)\nreturn data\nresponse = client.get('/synthesizer')\ndata: list = response.json()\ndata = __process_data(data)\nreturn SynthesizersList(data)\ndef _is_initialized(self) -&gt; bool:\n\"\"\"Determine if a synthesizer is instanciated or not.\n        Returns:\n            True if the synthesizer is instanciated\n        \"\"\"\nreturn self._model is not None\n@staticmethod\ndef _resolve_api_status(api_status: dict) -&gt; Status:\n\"\"\"Determine the status of the Synthesizer.\n        The status of the synthesizer instance is determined by the state of\n        its different components.\n        Arguments:\n            api_status (dict): json from the endpoint GET /synthesizer\n        Returns:\n            Synthesizer Status\n        \"\"\"\nstatus = Status(api_status.get('state', Status.UNKNOWN.name))\nprepare = PrepareState(api_status.get('prepare', {}).get(\n'state', PrepareState.UNKNOWN.name))\nif prepare == PrepareState.FAILED:\nstatus = Status.FAILED\nreturn status\n</code></pre>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.status","title":"<code>status: Status</code>  <code>property</code>","text":"<p>Get the status of a synthesizer instance.</p> <p>Returns:</p> Type Description <code>Status</code> <p>Synthesizer status</p>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.uid","title":"<code>uid: UID</code>  <code>property</code>","text":"<p>Get the status of a synthesizer instance.</p> <p>Returns:</p> Type Description <code>UID</code> <p>Synthesizer status</p>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.fit","title":"<code>fit(X, datatype=None, dataset_attrs=None, target=None, name=None)</code>","text":"<p>Fit the synthesizer.</p> <p>The synthesizer accepts as training dataset either a pandas <code>DataFrame</code> directly or a YData <code>DataSource</code>. When the training dataset is a pandas <code>DataFrame</code>, the argument <code>datatype</code> is required as it cannot be deduced.</p> <p>Similarly, <code>dataset_attrs</code> is mandatory for <code>TimeSeries</code> dataset to specify the <code>sortbykey</code> columns.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[DataSource, pandas.DataFrame]</code> <p>Training dataset</p> required <code>datatype</code> <code>Optional[Union[DataSourceType, str]]</code> <p>(optional) Dataset datatype - required if <code>X</code> is a <code>pandas.DataFrame</code></p> <code>None</code> <code>dataset_attrs</code> <code>Optional[Union[DataSourceAttrs, dict]]</code> <p>(optional) Dataset attributes</p> <code>None</code> <code>target</code> <code>Optional[str]</code> <p>(optional) Metadata associated to the datasource</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>(optional) Synthesizer instance name</p> <code>None</code> Source code in <code>ydata/sdk/synthesizers/synthesizer.py</code> <pre><code>def fit(self, X: Union[DataSource, pdDataFrame], datatype: Optional[Union[DataSourceType, str]] = None, dataset_attrs: Optional[Union[DataSourceAttrs, dict]] = None, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n    The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n    When the training dataset is a pandas [`DataFrame`][pandas.DataFrame], the argument `datatype` is required as it cannot be deduced.\n    Similarly, `dataset_attrs` is mandatory for [`TimeSeries`][ydata.sdk.datasources.DataSourceType.TIMESERIES] dataset to specify the `sortbykey` columns.\n    Arguments:\n        X (Union[DataSource, pandas.DataFrame]): Training dataset\n        datatype (Optional[Union[DataSourceType, str]]): (optional) Dataset datatype - required if `X` is a [`pandas.DataFrame`][pandas.DataFrame]\n        dataset_attrs (Optional[Union[DataSourceAttrs, dict]]): (optional) Dataset attributes\n        target (Optional[str]): (optional) Metadata associated to the datasource\n        name (Optional[str]): (optional) Synthesizer instance name\n    \"\"\"\nif self._is_initialized():\nraise AlreadyFittedError()\n_datatype = DataSourceType(datatype) if isinstance(\nX, pdDataFrame) else DataSourceType(X.datatype)\ndataset_attrs = dataset_attrs if dataset_attrs is not None else {}\nif isinstance(dataset_attrs, dict):\ndataset_attrs = DataSourceAttrs(**dataset_attrs)\nself._validate_datasource_attributes(X, dataset_attrs, _datatype, target)\n# If the training data is a pandas dataframe, we first need to create a data source and then the instance\nif isinstance(X, pdDataFrame):\n_X = LocalDataSource(source=X, datatype=_datatype, client=self._client)\nelse:\nif datatype is not None:\nwarn(\"When the training data is a DataSource, the argument `datatype` is ignored.\",\nDataSourceTypeWarning)\n_X = X\nif _X.status != dsStatus.AVAILABLE:\nraise DataSourceNotAvailableError(\nf\"The datasource '{_X.uid}' is not available (status = {_X.status.value})\")\nif isinstance(dataset_attrs, dict):\ndataset_attrs = DataSourceAttrs(**dataset_attrs)\nself._fit_from_datasource(\nX=_X, dataset_attrs=dataset_attrs, target=target, name=name)\n</code></pre>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.get","title":"<code>get(uid, client=None)</code>  <code>staticmethod</code>","text":"<p>List the synthesizer instances.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>synthesizer instance uid</p> required <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseSynthesizer</code> <p>Synthesizer instance</p> Source code in <code>ydata/sdk/synthesizers/synthesizer.py</code> <pre><code>@staticmethod\n@init_client\ndef get(uid: str, client: Optional[Client] = None) -&gt; \"BaseSynthesizer\":\n\"\"\"List the synthesizer instances.\n    Arguments:\n        uid (str): synthesizer instance uid\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        Synthesizer instance\n    \"\"\"\nresponse = client.get(f'/synthesizer/{uid}')\ndata: list = response.json()\nmodel, synth_cls = BaseSynthesizer._model_from_api(\ndata['dataSource']['dataType'], data)\nreturn ModelFactoryMixin._init_from_model_data(synth_cls, model)\n</code></pre>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.list","title":"<code>list(client=None)</code>  <code>staticmethod</code>","text":"<p>List the synthesizer instances.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>(optional) Client to connect to the backend</p> <code>None</code> <p>Returns:</p> Type Description <code>SynthesizersList</code> <p>List of synthesizers</p> Source code in <code>ydata/sdk/synthesizers/synthesizer.py</code> <pre><code>@staticmethod\n@init_client\ndef list(client: Optional[Client] = None) -&gt; SynthesizersList:\n\"\"\"List the synthesizer instances.\n    Arguments:\n        client (Client): (optional) Client to connect to the backend\n    Returns:\n        List of synthesizers\n    \"\"\"\ndef __process_data(data: list) -&gt; list:\nto_del = ['metadata', 'report', 'mode']\nfor e in data:\nfor k in to_del:\ne.pop(k, None)\nreturn data\nresponse = client.get('/synthesizer')\ndata: list = response.json()\ndata = __process_data(data)\nreturn SynthesizersList(data)\n</code></pre>"},{"location":"reference/api/synthesizers/base/#ydata.sdk.synthesizers.synthesizer.BaseSynthesizer.sample","title":"<code>sample()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to sample from a synthesizer.</p> Source code in <code>ydata/sdk/synthesizers/synthesizer.py</code> <pre><code>@abstractmethod\ndef sample(self) -&gt; pdDataFrame:\n\"\"\"Abstract method to sample from a synthesizer.\"\"\"\n</code></pre>"},{"location":"reference/api/synthesizers/regular/","title":"Regular","text":"<p>         Bases: <code>BaseSynthesizer</code></p> Source code in <code>ydata/sdk/synthesizers/regular.py</code> <pre><code>class RegularSynthesizer(BaseSynthesizer):\ndef sample(self, n_samples: int = 1) -&gt; pdDataFrame:\n\"\"\"Sample from a [`RegularSynthesizer`][ydata.sdk.synthesizers.RegularSynthesizer]\n        instance.\n        Arguments:\n            n_samples (int): number of rows in the sample\n        Returns:\n            synthetic data\n        \"\"\"\nif n_samples &lt; 1:\nraise InputError(\"Parameter 'n_samples' must be greater than 0\")\nreturn self._sample(payload={\"numberOfRecords\": n_samples})\ndef fit(self, X: Union[DataSource, pdDataFrame], dataset_attrs: Optional[DataSourceAttrs] = None, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n        The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n        Arguments:\n            X (Union[DataSource, pandas.DataFrame]): Training dataset\n            dataset_attrs (Optional[Union[DataSourceAttrs, dict]]): (optional) Dataset attributes\n            target (Optional[str]): (optional) Target column\n            name (Optional[str]): (optional) Synthesizer instance name\n        \"\"\"\nBaseSynthesizer.fit(self, X=X, datatype=None,\ndataset_attrs=dataset_attrs, target=target, name=name)\ndef __repr__(self):\nif self._model is not None:\nreturn self._model.__repr__()\nelse:\nreturn \"RegularSynthesizer(Not Initialized)\"\n</code></pre>"},{"location":"reference/api/synthesizers/regular/#ydata.sdk.synthesizers.regular.RegularSynthesizer.fit","title":"<code>fit(X, dataset_attrs=None, target=None, name=None)</code>","text":"<p>Fit the synthesizer.</p> <p>The synthesizer accepts as training dataset either a pandas <code>DataFrame</code> directly or a YData <code>DataSource</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[DataSource, pandas.DataFrame]</code> <p>Training dataset</p> required <code>dataset_attrs</code> <code>Optional[Union[DataSourceAttrs, dict]]</code> <p>(optional) Dataset attributes</p> <code>None</code> <code>target</code> <code>Optional[str]</code> <p>(optional) Target column</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>(optional) Synthesizer instance name</p> <code>None</code> Source code in <code>ydata/sdk/synthesizers/regular.py</code> <pre><code>def fit(self, X: Union[DataSource, pdDataFrame], dataset_attrs: Optional[DataSourceAttrs] = None, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n    The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n    Arguments:\n        X (Union[DataSource, pandas.DataFrame]): Training dataset\n        dataset_attrs (Optional[Union[DataSourceAttrs, dict]]): (optional) Dataset attributes\n        target (Optional[str]): (optional) Target column\n        name (Optional[str]): (optional) Synthesizer instance name\n    \"\"\"\nBaseSynthesizer.fit(self, X=X, datatype=None,\ndataset_attrs=dataset_attrs, target=target, name=name)\n</code></pre>"},{"location":"reference/api/synthesizers/regular/#ydata.sdk.synthesizers.regular.RegularSynthesizer.sample","title":"<code>sample(n_samples=1)</code>","text":"<p>Sample from a <code>RegularSynthesizer</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>number of rows in the sample</p> <code>1</code> <p>Returns:</p> Type Description <code>pdDataFrame</code> <p>synthetic data</p> Source code in <code>ydata/sdk/synthesizers/regular.py</code> <pre><code>def sample(self, n_samples: int = 1) -&gt; pdDataFrame:\n\"\"\"Sample from a [`RegularSynthesizer`][ydata.sdk.synthesizers.RegularSynthesizer]\n    instance.\n    Arguments:\n        n_samples (int): number of rows in the sample\n    Returns:\n        synthetic data\n    \"\"\"\nif n_samples &lt; 1:\nraise InputError(\"Parameter 'n_samples' must be greater than 0\")\nreturn self._sample(payload={\"numberOfRecords\": n_samples})\n</code></pre>"},{"location":"reference/api/synthesizers/timeseries/","title":"TimeSeries","text":"<p>         Bases: <code>BaseSynthesizer</code></p> Source code in <code>ydata/sdk/synthesizers/timeseries.py</code> <pre><code>class TimeSeriesSynthesizer(BaseSynthesizer):\ndef sample(self, n_entities: Optional[int] = None) -&gt; pdDataFrame:\n\"\"\"Sample from a [`TimeSeriesSynthesizer`][ydata.sdk.synthesizers.TimeS\n        eriesSynthesizer] instance.\n        If a training dataset was not using any `entity` column, the Synthesizer assumes a single entity.\n        A [`TimeSeriesSynthesizer`][ydata.sdk.synthesizers.TimeSeriesSynthesizer] always sample the full trajectory of its entities.\n        Arguments:\n            n_entities (int): (optional) number of entities to sample. If `None`, uses the same number of entities as in the original dataset.\n        Returns:\n            synthetic data\n        \"\"\"\nif n_entities is not None and n_entities &lt; 1:\nraise InputError(\"Parameter 'n_entities' must be greater than 0\")\nreturn self._sample(payload={\"numberOfRecords\": n_entities})\ndef fit(self, X: Union[DataSource, pdDataFrame], dataset_attrs: DataSourceAttrs, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n        The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n        Similarly, `dataset_attrs` is mandatory for [`TimeSeries`][ydata.sdk.datasources.DataSourceType.TIMESERIES] dataset to specify the `sortbykey` columns.\n        Arguments:\n            X (Union[DataSource, pandas.DataFrame]): Training dataset\n            dataset_attrs (Union[DataSourceAttrs, dict]): Dataset attributes\n            target (Optional[str]): (optional) Metadata associated to the datasource\n            name (Optional[str]): (optional) Synthesizer instance name\n        \"\"\"\nBaseSynthesizer.fit(self, X=X, datatype=DataSourceType.TIMESERIES,\ndataset_attrs=dataset_attrs, target=target, name=name)\ndef __repr__(self):\nif self._model is not None:\nreturn self._model.__repr__()\nelse:\nreturn \"TimeSeriesSynthesizer(Not Initialized)\"\n</code></pre>"},{"location":"reference/api/synthesizers/timeseries/#ydata.sdk.synthesizers.timeseries.TimeSeriesSynthesizer.fit","title":"<code>fit(X, dataset_attrs, target=None, name=None)</code>","text":"<p>Fit the synthesizer.</p> <p>The synthesizer accepts as training dataset either a pandas <code>DataFrame</code> directly or a YData <code>DataSource</code>.</p> <p>Similarly, <code>dataset_attrs</code> is mandatory for <code>TimeSeries</code> dataset to specify the <code>sortbykey</code> columns.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[DataSource, pandas.DataFrame]</code> <p>Training dataset</p> required <code>dataset_attrs</code> <code>Union[DataSourceAttrs, dict]</code> <p>Dataset attributes</p> required <code>target</code> <code>Optional[str]</code> <p>(optional) Metadata associated to the datasource</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>(optional) Synthesizer instance name</p> <code>None</code> Source code in <code>ydata/sdk/synthesizers/timeseries.py</code> <pre><code>def fit(self, X: Union[DataSource, pdDataFrame], dataset_attrs: DataSourceAttrs, target: Optional[str] = None, name: Optional[str] = None) -&gt; None:\n\"\"\"Fit the synthesizer.\n    The synthesizer accepts as training dataset either a pandas [`DataFrame`][pandas.DataFrame] directly or a YData [`DataSource`][ydata.sdk.datasources.DataSource].\n    Similarly, `dataset_attrs` is mandatory for [`TimeSeries`][ydata.sdk.datasources.DataSourceType.TIMESERIES] dataset to specify the `sortbykey` columns.\n    Arguments:\n        X (Union[DataSource, pandas.DataFrame]): Training dataset\n        dataset_attrs (Union[DataSourceAttrs, dict]): Dataset attributes\n        target (Optional[str]): (optional) Metadata associated to the datasource\n        name (Optional[str]): (optional) Synthesizer instance name\n    \"\"\"\nBaseSynthesizer.fit(self, X=X, datatype=DataSourceType.TIMESERIES,\ndataset_attrs=dataset_attrs, target=target, name=name)\n</code></pre>"},{"location":"reference/api/synthesizers/timeseries/#ydata.sdk.synthesizers.timeseries.TimeSeriesSynthesizer.sample","title":"<code>sample(n_entities=None)</code>","text":"<p>Sample from a [<code>TimeSeriesSynthesizer</code>][ydata.sdk.synthesizers.TimeS eriesSynthesizer] instance.</p> <p>If a training dataset was not using any <code>entity</code> column, the Synthesizer assumes a single entity. A <code>TimeSeriesSynthesizer</code> always sample the full trajectory of its entities.</p> <p>Parameters:</p> Name Type Description Default <code>n_entities</code> <code>int</code> <p>(optional) number of entities to sample. If <code>None</code>, uses the same number of entities as in the original dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>pdDataFrame</code> <p>synthetic data</p> Source code in <code>ydata/sdk/synthesizers/timeseries.py</code> <pre><code>def sample(self, n_entities: Optional[int] = None) -&gt; pdDataFrame:\n\"\"\"Sample from a [`TimeSeriesSynthesizer`][ydata.sdk.synthesizers.TimeS\n    eriesSynthesizer] instance.\n    If a training dataset was not using any `entity` column, the Synthesizer assumes a single entity.\n    A [`TimeSeriesSynthesizer`][ydata.sdk.synthesizers.TimeSeriesSynthesizer] always sample the full trajectory of its entities.\n    Arguments:\n        n_entities (int): (optional) number of entities to sample. If `None`, uses the same number of entities as in the original dataset.\n    Returns:\n        synthetic data\n    \"\"\"\nif n_entities is not None and n_entities &lt; 1:\nraise InputError(\"Parameter 'n_entities' must be greater than 0\")\nreturn self._sample(payload={\"numberOfRecords\": n_entities})\n</code></pre>"},{"location":"support/help-troubleshooting/","title":"Help &amp; Troubleshooting","text":""}]}